/** Generated by the default template from graphql-java-generator */
package com.graphql_java_generator.client.domain.allGraphQLCases;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLContext;
import javax.ws.rs.client.Client;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.graphql_java_generator.GraphQLField;
import com.graphql_java_generator.annotation.GraphQLInputParameters;
import com.graphql_java_generator.annotation.GraphQLNonScalar;
import com.graphql_java_generator.annotation.GraphQLObjectType;
import com.graphql_java_generator.annotation.GraphQLQuery;
import com.graphql_java_generator.annotation.GraphQLScalar;
import com.graphql_java_generator.annotation.RequestType;
import com.graphql_java_generator.client.GraphQLConfiguration;
import com.graphql_java_generator.client.GraphqlClientUtils;
import com.graphql_java_generator.client.request.InputParameter;
import com.graphql_java_generator.client.request.ObjectResponse;
import com.graphql_java_generator.client.response.GraphQLRequestObject;
import com.graphql_java_generator.customscalars.GraphQLScalarTypeDate;
import com.graphql_java_generator.exception.GraphQLRequestExecutionException;
import com.graphql_java_generator.exception.GraphQLRequestPreparationException;

/**
 * @author generated by graphql-java-generator
 * @see <a href=
 *      "https://github.com/graphql-java-generator/graphql-java-generator">https://github.com/graphql-java-generator/graphql-java-generator</a>
 */
@GraphQLQuery(name = "MyQueryType", type = RequestType.query)
@GraphQLObjectType("MyQueryType")
public class MyQueryType implements GraphQLRequestObject {

	/** Logger for this class */
	private static Logger logger = LoggerFactory.getLogger(MyQueryType.class);

	GraphqlClientUtils graphqlClientUtils = new GraphqlClientUtils();

	GraphQLConfiguration configuration;

	public MyQueryType() {
		// No action
	}

	@JsonDeserialize(contentAs = Character.class)
	@JsonProperty("withoutParameters")
	@GraphQLNonScalar(fieldName = "withoutParameters", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	List<Character> withoutParameters;

	@GraphQLInputParameters(names = { "character" }, types = { "CharacterInput" })
	@JsonProperty("withOneOptionalParam")
	@GraphQLNonScalar(fieldName = "withOneOptionalParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character withOneOptionalParam;

	@GraphQLInputParameters(names = { "character" }, types = { "CharacterInput" })
	@JsonProperty("withOneMandatoryParam")
	@GraphQLNonScalar(fieldName = "withOneMandatoryParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character withOneMandatoryParam;

	@GraphQLInputParameters(names = { "nbResultat" }, types = { "Int" })
	@JsonProperty("withOneMandatoryParamDefaultValue")
	@GraphQLNonScalar(fieldName = "withOneMandatoryParamDefaultValue", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character withOneMandatoryParamDefaultValue;

	@GraphQLInputParameters(names = { "theHero", "num" }, types = { "DroidInput", "Int" })
	@JsonProperty("withTwoMandatoryParamDefaultVal")
	@GraphQLNonScalar(fieldName = "withTwoMandatoryParamDefaultVal", graphQLTypeSimpleName = "Droid", javaClass = Droid.class)
	Droid withTwoMandatoryParamDefaultVal;

	@GraphQLInputParameters(names = { "episode" }, types = { "Episode" })
	@JsonProperty("withEnum")
	@GraphQLNonScalar(fieldName = "withEnum", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character withEnum;

	@JsonDeserialize(contentAs = Character.class)
	@GraphQLInputParameters(names = { "firstName", "characters" }, types = { "String", "CharacterInput" })
	@JsonProperty("withList")
	@GraphQLNonScalar(fieldName = "withList", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	List<Character> withList;

	@GraphQLInputParameters(names = { "input" }, types = { "AllFieldCasesInput" })
	@JsonProperty("allFieldCases")
	@GraphQLNonScalar(fieldName = "allFieldCases", graphQLTypeSimpleName = "AllFieldCases", javaClass = AllFieldCases.class)
	AllFieldCases allFieldCases;

	@JsonDeserialize(contentAs = AnyCharacter.class)
	@GraphQLInputParameters(names = { "human1", "human2", "droid1", "droid2" }, types = { "HumanInput", "HumanInput",
			"DroidInput", "DroidInput" })
	@JsonProperty("unionTest")
	@GraphQLNonScalar(fieldName = "unionTest", graphQLTypeSimpleName = "AnyCharacter", javaClass = AnyCharacter.class)
	List<AnyCharacter> unionTest;

	@GraphQLInputParameters(names = { "errorLabel" }, types = { "String" })
	@JsonProperty("error")
	@GraphQLNonScalar(fieldName = "error", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character error;

	@JsonProperty("aBreak")
	@GraphQLNonScalar(fieldName = "aBreak", graphQLTypeSimpleName = "break", javaClass = _break.class)
	_break aBreak;

	@JsonDeserialize(contentAs = String.class)
	@GraphQLInputParameters(names = { "uppercase" }, types = { "Boolean" })
	@JsonProperty("directiveOnQuery")
	@GraphQLScalar(fieldName = "directiveOnQuery", graphQLTypeSimpleName = "String", javaClass = String.class)
	List<String> directiveOnQuery;

	@JsonProperty("directiveOnField")
	@GraphQLNonScalar(fieldName = "directiveOnField", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	Character directiveOnField;

	@JsonProperty("relay")
	@GraphQLNonScalar(fieldName = "relay", graphQLTypeSimpleName = "MyQueryType", javaClass = MyQueryType.class)
	MyQueryType relay;

	@JsonProperty("__schema")
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	__Schema __schema;

	@GraphQLInputParameters(names = { "name" }, types = { "String" })
	@JsonProperty("__type")
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	__Type __type;

	public void setWithoutParameters(List<Character> withoutParameters) {
		this.withoutParameters = withoutParameters;
	}

	public List<Character> getWithoutParameters() {
		return withoutParameters;
	}

	public void setWithOneOptionalParam(Character withOneOptionalParam) {
		this.withOneOptionalParam = withOneOptionalParam;
	}

	public Character getWithOneOptionalParam() {
		return withOneOptionalParam;
	}

	public void setWithOneMandatoryParam(Character withOneMandatoryParam) {
		this.withOneMandatoryParam = withOneMandatoryParam;
	}

	public Character getWithOneMandatoryParam() {
		return withOneMandatoryParam;
	}

	public void setWithOneMandatoryParamDefaultValue(Character withOneMandatoryParamDefaultValue) {
		this.withOneMandatoryParamDefaultValue = withOneMandatoryParamDefaultValue;
	}

	public Character getWithOneMandatoryParamDefaultValue() {
		return withOneMandatoryParamDefaultValue;
	}

	public void setWithTwoMandatoryParamDefaultVal(Droid withTwoMandatoryParamDefaultVal) {
		this.withTwoMandatoryParamDefaultVal = withTwoMandatoryParamDefaultVal;
	}

	public Droid getWithTwoMandatoryParamDefaultVal() {
		return withTwoMandatoryParamDefaultVal;
	}

	public void setWithEnum(Character withEnum) {
		this.withEnum = withEnum;
	}

	public Character getWithEnum() {
		return withEnum;
	}

	public void setWithList(List<Character> withList) {
		this.withList = withList;
	}

	public List<Character> getWithList() {
		return withList;
	}

	public void setAllFieldCases(AllFieldCases allFieldCases) {
		this.allFieldCases = allFieldCases;
	}

	public AllFieldCases getAllFieldCases() {
		return allFieldCases;
	}

	public void setUnionTest(List<AnyCharacter> unionTest) {
		this.unionTest = unionTest;
	}

	public List<AnyCharacter> getUnionTest() {
		return unionTest;
	}

	public void setError(Character error) {
		this.error = error;
	}

	public Character getError() {
		return error;
	}

	public void setABreak(_break aBreak) {
		this.aBreak = aBreak;
	}

	public _break getABreak() {
		return aBreak;
	}

	public void setDirectiveOnQuery(List<String> directiveOnQuery) {
		this.directiveOnQuery = directiveOnQuery;
	}

	public List<String> getDirectiveOnQuery() {
		return directiveOnQuery;
	}

	public void setDirectiveOnField(Character directiveOnField) {
		this.directiveOnField = directiveOnField;
	}

	public Character getDirectiveOnField() {
		return directiveOnField;
	}

	public void setRelay(MyQueryType relay) {
		this.relay = relay;
	}

	public MyQueryType getRelay() {
		return relay;
	}

	public void set__schema(__Schema __schema) {
		this.__schema = __schema;
	}

	public __Schema get__schema() {
		return __schema;
	}

	public void set__type(__Type __type) {
		this.__type = __type;
	}

	public __Type get__type() {
		return __type;
	}

	@Override
	public String toString() {
		return "MyQueryType {" + "withoutParameters: " + withoutParameters + ", " + "withOneOptionalParam: "
				+ withOneOptionalParam + ", " + "withOneMandatoryParam: " + withOneMandatoryParam + ", "
				+ "withOneMandatoryParamDefaultValue: " + withOneMandatoryParamDefaultValue + ", "
				+ "withTwoMandatoryParamDefaultVal: " + withTwoMandatoryParamDefaultVal + ", " + "withEnum: " + withEnum
				+ ", " + "withList: " + withList + ", " + "allFieldCases: " + allFieldCases + ", " + "unionTest: "
				+ unionTest + ", " + "error: " + error + ", " + "aBreak: " + aBreak + ", " + "directiveOnQuery: "
				+ directiveOnQuery + ", " + "directiveOnField: " + directiveOnField + ", " + "relay: " + relay + ", "
				+ "__schema: " + __schema + ", " + "__type: " + __type + "}";
	}

	/**
	 * Enum of field names
	 */
	public static enum Field implements GraphQLField {
		WithoutParameters("withoutParameters"), WithOneOptionalParam("withOneOptionalParam"), WithOneMandatoryParam(
				"withOneMandatoryParam"), WithOneMandatoryParamDefaultValue(
						"withOneMandatoryParamDefaultValue"), WithTwoMandatoryParamDefaultVal(
								"withTwoMandatoryParamDefaultVal"), WithEnum(
										"withEnum"), WithList("withList"), AllFieldCases("allFieldCases"), UnionTest(
												"unionTest"), Error("error"), ABreak("aBreak"), DirectiveOnQuery(
														"directiveOnQuery"), DirectiveOnField(
																"directiveOnField"), Relay("relay"), __schema(
																		"__schema"), __type("__type");

		private String fieldName;

		Field(String fieldName) {
			this.fieldName = fieldName;
		}

		@Override
		public String getFieldName() {
			return fieldName;
		}

		@Override
		public Class<?> getGraphQLType() {
			return this.getClass().getDeclaringClass();
		}

	}

	public static Builder builder() {
		return new Builder();
	}

	/**
	 * Builder
	 */
	public static class Builder {
		private List<Character> withoutParameters;
		private Character withOneOptionalParam;
		private Character withOneMandatoryParam;
		private Character withOneMandatoryParamDefaultValue;
		private Droid withTwoMandatoryParamDefaultVal;
		private Character withEnum;
		private List<Character> withList;
		private AllFieldCases allFieldCases;
		private List<AnyCharacter> unionTest;
		private Character error;
		private _break aBreak;
		private List<String> directiveOnQuery;
		private Character directiveOnField;
		private MyQueryType relay;
		private __Schema __schema;
		private __Type __type;

		public Builder withWithoutParameters(List<Character> withoutParameters) {
			this.withoutParameters = withoutParameters;
			return this;
		}

		public Builder withWithOneOptionalParam(Character withOneOptionalParam) {
			this.withOneOptionalParam = withOneOptionalParam;
			return this;
		}

		public Builder withWithOneMandatoryParam(Character withOneMandatoryParam) {
			this.withOneMandatoryParam = withOneMandatoryParam;
			return this;
		}

		public Builder withWithOneMandatoryParamDefaultValue(Character withOneMandatoryParamDefaultValue) {
			this.withOneMandatoryParamDefaultValue = withOneMandatoryParamDefaultValue;
			return this;
		}

		public Builder withWithTwoMandatoryParamDefaultVal(Droid withTwoMandatoryParamDefaultVal) {
			this.withTwoMandatoryParamDefaultVal = withTwoMandatoryParamDefaultVal;
			return this;
		}

		public Builder withWithEnum(Character withEnum) {
			this.withEnum = withEnum;
			return this;
		}

		public Builder withWithList(List<Character> withList) {
			this.withList = withList;
			return this;
		}

		public Builder withAllFieldCases(AllFieldCases allFieldCases) {
			this.allFieldCases = allFieldCases;
			return this;
		}

		public Builder withUnionTest(List<AnyCharacter> unionTest) {
			this.unionTest = unionTest;
			return this;
		}

		public Builder withError(Character error) {
			this.error = error;
			return this;
		}

		public Builder withABreak(_break aBreak) {
			this.aBreak = aBreak;
			return this;
		}

		public Builder withDirectiveOnQuery(List<String> directiveOnQuery) {
			this.directiveOnQuery = directiveOnQuery;
			return this;
		}

		public Builder withDirectiveOnField(Character directiveOnField) {
			this.directiveOnField = directiveOnField;
			return this;
		}

		public Builder withRelay(MyQueryType relay) {
			this.relay = relay;
			return this;
		}

		public Builder with__schema(__Schema __schema) {
			this.__schema = __schema;
			return this;
		}

		public Builder with__type(__Type __type) {
			this.__type = __type;
			return this;
		}

		public MyQueryType build() {
			MyQueryType _object = new MyQueryType();
			_object.setWithoutParameters(withoutParameters);
			_object.setWithOneOptionalParam(withOneOptionalParam);
			_object.setWithOneMandatoryParam(withOneMandatoryParam);
			_object.setWithOneMandatoryParamDefaultValue(withOneMandatoryParamDefaultValue);
			_object.setWithTwoMandatoryParamDefaultVal(withTwoMandatoryParamDefaultVal);
			_object.setWithEnum(withEnum);
			_object.setWithList(withList);
			_object.setAllFieldCases(allFieldCases);
			_object.setUnionTest(unionTest);
			_object.setError(error);
			_object.setABreak(aBreak);
			_object.setDirectiveOnQuery(directiveOnQuery);
			_object.setDirectiveOnField(directiveOnField);
			_object.setRelay(relay);
			_object.set__schema(__schema);
			_object.set__type(__type);
			return _object;
		}
	}

	/**
	 * This constructor expects the URI of the GraphQL server. This constructor works only for http servers, not for
	 * https ones.<BR/>
	 * For example: http://my.server.com/graphql
	 * 
	 * @param graphqlEndpoint
	 *            the http URI for the GraphQL endpoint
	 */
	public MyQueryType(String graphqlEndpoint) {
		this.configuration = new GraphQLConfiguration(graphqlEndpoint);
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This constructor expects the URI of the GraphQL server. This constructor works only for https servers, not for
	 * http ones.<BR/>
	 * For example: https://my.server.com/graphql<BR/>
	 * <BR/>
	 * {@link SSLContext} and {@link HostnameVerifier} are regular Java stuff. You'll find lots of documentation on the
	 * web. The StarWars sample is based on the <A HREF=
	 * "http://www.thinkcode.se/blog/2019/01/27/a-jersey-client-supporting-https">http://www.thinkcode.se/blog/2019/01/27/a-jersey-client-supporting-https</A>
	 * blog. But this sample implements a noHostVerification, which of course, is the simplest but the safest way to go.
	 * 
	 * @param graphqlEndpoint
	 *            the https URI for the GraphQL endpoint
	 * @param sslContext
	 * @param hostnameVerifier
	 */
	public MyQueryType(String graphqlEndpoint, SSLContext sslContext, HostnameVerifier hostnameVerifier) {
		this.configuration = new GraphQLConfiguration(graphqlEndpoint, sslContext, hostnameVerifier);
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This constructor expects the URI of the GraphQL server and a configured JAX-RS client that gives the opportunity
	 * to customise the REST request<BR/>
	 * For example: http://my.server.com/graphql
	 *
	 * @param graphqlEndpoint
	 *            the http URI for the GraphQL endpoint
	 * @param client
	 *            {@link Client} javax.ws.rs.client.Client to support customization of the rest request
	 * @param objectMapper
	 *            {@link ObjectMapper} com.fasterxml.jackson.databind.ObjectMapper to support configurable mapping
	 */
	public MyQueryType(String graphqlEndpoint, Client client, ObjectMapper objectMapper) {
		this.configuration = new GraphQLConfiguration(graphqlEndpoint, client, objectMapper);
		CustomScalarRegistryInitializer.initCustomScalarRegistry();
		DirectiveRegistryInitializer.initDirectiveRegistry();
	}

	/**
	 * This method takes a full query definition, and executes the GraphQL request against the GraphQL server. That is,
	 * the query contains the full string that <B><U>follows</U></B> the query/mutation/subscription keyword.<BR/>
	 * For instance:
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("heroParam", heroParamValue);
	 * params.put("skip", Boolean.FALSE);
	 * 
	 * Character c = myQyeryType.execWithBindValues(
	 * 		"{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}",
	 * 		params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above). It must ommit the
	 *            query/mutation/subscription keyword, and start by the first { that follows.It may contain directives,
	 *            as explained in the GraphQL specs.
	 * @param parameters
	 *            The map of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}. The key is the parameter name, as
	 *            defined in the query (in the above sample: heroParam is an optional parameter and skip is a mandatory
	 *            one). The value is the parameter vale in its Java type (for instance a {@link Date} for the
	 *            {@link GraphQLScalarTypeDate}). The parameters which value is missing in this map will no be
	 *            transmitted toward the GraphQL server.
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	public MyQueryTypeResponse execWithBindValues(String queryResponseDef, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query {} ", queryResponseDef);
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return exec(objectResponse, parameters);
	}

	/**
	 * This method takes a full query definition, and executes the GraphQL request against the GraphQL server. That is,
	 * the query contains the full string that <B><U>follows</U></B> the query/mutation/subscription keyword.<BR/>
	 * For instance:
	 * 
	 * <PRE>
	 * Character c = myQyeryType.execWithBindValues(
	 * 		"{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}",
	 * 		"heroParam", heroParamValue, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above). It must ommit the
	 *            query/mutation/subscription keyword, and start by the first { that follows.It may contain directives,
	 *            as explained in the GraphQL specs.
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	public MyQueryTypeResponse exec(String queryResponseDef, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query {} ", queryResponseDef);
		ObjectResponse objectResponse = getResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return execWithBindValues(objectResponse, graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * Here is a sample (and please have a look to the GraphQL site for more information):
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * 
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	objectResponse = myQueryType.getResponseBuilder()
	 * 			.withQueryResponseDef("{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("heroParam", heroParamValue);
	 * params.put("skip", Boolean.FALSE);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Board> boards = queryType.execWithBindValues(objectResponse, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	public MyQueryTypeResponse execWithBindValues(ObjectResponse objectResponse, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			if (parameters == null) {
				logger.trace("Executing of query without parameters");
			} else {
				StringBuffer sb = new StringBuffer("Executing of root query with parameters: ");
				boolean addComma = false;
				for (String key : parameters.keySet()) {
					sb.append(key).append(":").append(parameters.get(key));
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
				logger.trace(sb.toString());
			}
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'MyQueryType'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		return configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryTypeResponse.class);
	}

	/**
	 * This method takes a predefined {@link ObjectResponse} as the definition for the GraphQL request, and executes the
	 * GraphQL request against the GraphQL server. It offers a logging of the call (if in debug mode), or of the call
	 * and its parameters (if in trace mode).<BR/>
	 * Here is a sample (and please have a look to the GraphQL site for more information):
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * 
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	 objectResponse = myQueryType.getResponseBuilder()
	 * 			.withQueryResponseDef("{hero(param:?heroParam) @include(if:true) {id name @skip(if: ?skip) appearsIn friends {id name}}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Board> boards = queryType.exec(objectResponse, "heroParam", heroParamValue, "skip", Boolean.FALSE);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	public MyQueryTypeResponse exec(ObjectResponse objectResponse, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		return execWithBindValues(objectResponse, graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the full query, as expected by the exec and
	 * execWithBindValues methods.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class);
	}

	/**
	 * Get the {@link GraphQLRequest} for Full request. It's easier to directly execute:
	 * 
	 * <PRE>
	 * GraphQLRequest request = new GraphQLRequest(fullRequest);
	 * </PRE>
	 * 
	 * @param fullRequest
	 *            The full GraphQLRequest, as specified in the GraphQL specification
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getGraphQLRequest(String fullRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(fullRequest);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * List<Character> c = myQyeryType
	 * 		.withoutParametersWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}", params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withoutParameters", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withoutParametersWithBindValues(
			String queryResponseDef, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withoutParameters' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithoutParametersResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withoutParameters(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * List<Character> c = myQyeryType.withoutParameters("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		"skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withoutParameters", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withoutParameters(
			String queryResponseDef, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withoutParameters' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithoutParametersResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withoutParametersWithBindValues(objectResponse,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Character> ret = queryType.withoutParametersWithBindValues(response, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withoutParameters", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withoutParametersWithBindValues(
			ObjectResponse objectResponse, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withoutParameters' with parameters: ");
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withoutParameters'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithoutParameters();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Character> ret = queryType.withoutParameters(response, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withoutParameters", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withoutParameters(
			ObjectResponse objectResponse, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withoutParameters' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withoutParameters' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithoutParameters();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the
	 * withoutParameters query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithoutParametersResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "withoutParameters",
				RequestType.query);
	}

	/**
	 * Get the {@link GraphQLRequest} for the withoutParameters query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithoutParametersGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withoutParameters");
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType.withOneOptionalParamWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", character, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param character
	 *            Parameter for the withOneOptionalParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneOptionalParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneOptionalParamWithBindValues(
			String queryResponseDef, CharacterInput character, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneOptionalParam' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneOptionalParamResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withOneOptionalParam(objectResponse, character, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.withOneOptionalParam("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		character, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param character
	 *            Parameter for the withOneOptionalParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneOptionalParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneOptionalParam(
			String queryResponseDef, CharacterInput character, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneOptionalParam' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneOptionalParamResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withOneOptionalParamWithBindValues(objectResponse, character,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneOptionalParamWithBindValues(response, character, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param character
	 *            Parameter for the withOneOptionalParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneOptionalParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneOptionalParamWithBindValues(
			ObjectResponse objectResponse, CharacterInput character, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withOneOptionalParam' with parameters: {} ", character);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneOptionalParam'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithOneOptionalParamCharacter", character);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneOptionalParam();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneOptionalParam(response, character, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param character
	 *            Parameter for the withOneOptionalParam field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneOptionalParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneOptionalParam(
			ObjectResponse objectResponse, CharacterInput character, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withOneOptionalParam' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneOptionalParam' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithOneOptionalParamCharacter", character);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneOptionalParam();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the
	 * withOneOptionalParam query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithOneOptionalParamResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "withOneOptionalParam",
				RequestType.query,
				InputParameter.newBindParameter("character", "myQueryTypeWithOneOptionalParamCharacter", false, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withOneOptionalParam query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithOneOptionalParamGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withOneOptionalParam",
				InputParameter.newBindParameter("character", "myQueryTypeWithOneOptionalParamCharacter", false, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType.withOneMandatoryParamWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", character, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param character
	 *            Parameter for the withOneMandatoryParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamWithBindValues(
			String queryResponseDef, CharacterInput character, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneMandatoryParam' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneMandatoryParamResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withOneMandatoryParam(objectResponse, character, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.withOneMandatoryParam("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		character, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param character
	 *            Parameter for the withOneMandatoryParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParam(
			String queryResponseDef, CharacterInput character, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneMandatoryParam' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneMandatoryParamResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return withOneMandatoryParamWithBindValues(objectResponse, character,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneMandatoryParamWithBindValues(response, character, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param character
	 *            Parameter for the withOneMandatoryParam field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamWithBindValues(
			ObjectResponse objectResponse, CharacterInput character, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withOneMandatoryParam' with parameters: {} ", character);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneMandatoryParam'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithOneMandatoryParamCharacter", character);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneMandatoryParam();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneMandatoryParam(response, character, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param character
	 *            Parameter for the withOneMandatoryParam field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParam", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParam(
			ObjectResponse objectResponse, CharacterInput character, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withOneMandatoryParam' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneMandatoryParam' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithOneMandatoryParamCharacter", character);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneMandatoryParam();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the
	 * withOneMandatoryParam query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithOneMandatoryParamResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "withOneMandatoryParam",
				RequestType.query,
				InputParameter.newBindParameter("character", "myQueryTypeWithOneMandatoryParamCharacter", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withOneMandatoryParam query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithOneMandatoryParamGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withOneMandatoryParam",
				InputParameter.newBindParameter("character", "myQueryTypeWithOneMandatoryParamCharacter", true, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType.withOneMandatoryParamDefaultValueWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", nbResultat, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param nbResultat
	 *            Parameter for the withOneMandatoryParamDefaultValue field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParamDefaultValue", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamDefaultValueWithBindValues(
			String queryResponseDef, Integer nbResultat, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneMandatoryParamDefaultValue' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneMandatoryParamDefaultValueResponseBuilder()
				.withQueryResponseDef(queryResponseDef).build();
		return withOneMandatoryParamDefaultValue(objectResponse, nbResultat, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.withOneMandatoryParamDefaultValue(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", nbResultat, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param nbResultat
	 *            Parameter for the withOneMandatoryParamDefaultValue field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParamDefaultValue", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamDefaultValue(
			String queryResponseDef, Integer nbResultat, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withOneMandatoryParamDefaultValue' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithOneMandatoryParamDefaultValueResponseBuilder()
				.withQueryResponseDef(queryResponseDef).build();
		return withOneMandatoryParamDefaultValueWithBindValues(objectResponse, nbResultat,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneMandatoryParamDefaultValueWithBindValues(response, nbResultat, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param nbResultat
	 *            Parameter for the withOneMandatoryParamDefaultValue field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParamDefaultValue", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamDefaultValueWithBindValues(
			ObjectResponse objectResponse, Integer nbResultat, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withOneMandatoryParamDefaultValue' with parameters: {} ", nbResultat);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneMandatoryParamDefaultValue'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithOneMandatoryParamDefaultValueNbResultat", nbResultat);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneMandatoryParamDefaultValue();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withOneMandatoryParamDefaultValue(response, nbResultat, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param nbResultat
	 *            Parameter for the withOneMandatoryParamDefaultValue field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withOneMandatoryParamDefaultValue", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withOneMandatoryParamDefaultValue(
			ObjectResponse objectResponse, Integer nbResultat, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withOneMandatoryParamDefaultValue' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withOneMandatoryParamDefaultValue' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithOneMandatoryParamDefaultValueNbResultat", nbResultat);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithOneMandatoryParamDefaultValue();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the
	 * withOneMandatoryParamDefaultValue query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithOneMandatoryParamDefaultValueResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class,
				"withOneMandatoryParamDefaultValue", RequestType.query, InputParameter.newBindParameter("nbResultat",
						"myQueryTypeWithOneMandatoryParamDefaultValueNbResultat", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withOneMandatoryParamDefaultValue query, created with the given Partial
	 * request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithOneMandatoryParamDefaultValueGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withOneMandatoryParamDefaultValue", InputParameter
				.newBindParameter("nbResultat", "myQueryTypeWithOneMandatoryParamDefaultValueNbResultat", true, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Droid c = myQyeryType.withTwoMandatoryParamDefaultValWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", theHero, num, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param theHero
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param num
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withTwoMandatoryParamDefaultVal", graphQLTypeSimpleName = "Droid", javaClass = Droid.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Droid withTwoMandatoryParamDefaultValWithBindValues(
			String queryResponseDef, DroidInput theHero, Integer num, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withTwoMandatoryParamDefaultVal' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithTwoMandatoryParamDefaultValResponseBuilder()
				.withQueryResponseDef(queryResponseDef).build();
		return withTwoMandatoryParamDefaultVal(objectResponse, theHero, num, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Droid c = myQyeryType.withTwoMandatoryParamDefaultVal("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		theHero, num, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param theHero
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param num
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withTwoMandatoryParamDefaultVal", graphQLTypeSimpleName = "Droid", javaClass = Droid.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Droid withTwoMandatoryParamDefaultVal(
			String queryResponseDef, DroidInput theHero, Integer num, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withTwoMandatoryParamDefaultVal' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithTwoMandatoryParamDefaultValResponseBuilder()
				.withQueryResponseDef(queryResponseDef).build();
		return withTwoMandatoryParamDefaultValWithBindValues(objectResponse, theHero, num,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Droid ret = queryType.withTwoMandatoryParamDefaultValWithBindValues(response, theHero, num, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param theHero
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param num
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withTwoMandatoryParamDefaultVal", graphQLTypeSimpleName = "Droid", javaClass = Droid.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Droid withTwoMandatoryParamDefaultValWithBindValues(
			ObjectResponse objectResponse, DroidInput theHero, Integer num, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withTwoMandatoryParamDefaultVal' with parameters: {}, {} ", theHero, num);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withTwoMandatoryParamDefaultVal'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithTwoMandatoryParamDefaultValTheHero", theHero);
		parameters.put("myQueryTypeWithTwoMandatoryParamDefaultValNum", num);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithTwoMandatoryParamDefaultVal();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Droid ret = queryType.withTwoMandatoryParamDefaultVal(response, theHero, num, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param theHero
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param num
	 *            Parameter for the withTwoMandatoryParamDefaultVal field of MyQueryType, as defined in the GraphQL
	 *            schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withTwoMandatoryParamDefaultVal", graphQLTypeSimpleName = "Droid", javaClass = Droid.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Droid withTwoMandatoryParamDefaultVal(
			ObjectResponse objectResponse, DroidInput theHero, Integer num, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withTwoMandatoryParamDefaultVal' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withTwoMandatoryParamDefaultVal' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithTwoMandatoryParamDefaultValTheHero", theHero);
		parameters.put("myQueryTypeWithTwoMandatoryParamDefaultValNum", num);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithTwoMandatoryParamDefaultVal();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Droid, as expected by the
	 * withTwoMandatoryParamDefaultVal query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithTwoMandatoryParamDefaultValResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class,
				"withTwoMandatoryParamDefaultVal", RequestType.query,
				InputParameter.newBindParameter("theHero", "myQueryTypeWithTwoMandatoryParamDefaultValTheHero", true,
						null),
				InputParameter.newBindParameter("num", "myQueryTypeWithTwoMandatoryParamDefaultValNum", false, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withTwoMandatoryParamDefaultVal query, created with the given Partial
	 * request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithTwoMandatoryParamDefaultValGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withTwoMandatoryParamDefaultVal",
				InputParameter.newBindParameter("theHero", "myQueryTypeWithTwoMandatoryParamDefaultValTheHero", true,
						null),
				InputParameter.newBindParameter("num", "myQueryTypeWithTwoMandatoryParamDefaultValNum", false, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType.withEnumWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		episode, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param episode
	 *            Parameter for the withEnum field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withEnum", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withEnumWithBindValues(
			String queryResponseDef, Episode episode, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withEnum' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithEnumResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return withEnum(objectResponse, episode, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.withEnum("{id name @skip(if: false) appearsIn friends {id name}}", episode, "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param episode
	 *            Parameter for the withEnum field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withEnum", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withEnum(String queryResponseDef,
			Episode episode, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withEnum' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithEnumResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return withEnumWithBindValues(objectResponse, episode,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withEnumWithBindValues(response, episode, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param episode
	 *            Parameter for the withEnum field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withEnum", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withEnumWithBindValues(
			ObjectResponse objectResponse, Episode episode, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withEnum' with parameters: {} ", episode);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withEnum'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithEnumEpisode", episode);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithEnum();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.withEnum(response, episode, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param episode
	 *            Parameter for the withEnum field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withEnum", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character withEnum(ObjectResponse objectResponse,
			Episode episode, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withEnum' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withEnum' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithEnumEpisode", episode);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithEnum();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the withEnum
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithEnumResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "withEnum",
				RequestType.query,
				InputParameter.newBindParameter("episode", "myQueryTypeWithEnumEpisode", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withEnum query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithEnumGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withEnum",
				InputParameter.newBindParameter("episode", "myQueryTypeWithEnumEpisode", true, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * List<Character> c = myQyeryType.withListWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		firstName, characters, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param firstName
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param characters
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withList", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withListWithBindValues(
			String queryResponseDef, String firstName, List<CharacterInput> characters, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withList' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithListResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return withList(objectResponse, firstName, characters, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * List<Character> c = myQyeryType.withList("{id name @skip(if: false) appearsIn friends {id name}}", firstName,
	 * 		characters, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param firstName
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param characters
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withList", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withList(String queryResponseDef,
			String firstName, List<CharacterInput> characters, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'withList' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getWithListResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return withListWithBindValues(objectResponse, firstName, characters,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Character> ret = queryType.withListWithBindValues(response, firstName, characters, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param firstName
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param characters
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withList", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withListWithBindValues(
			ObjectResponse objectResponse, String firstName, List<CharacterInput> characters,
			Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'withList' with parameters: {}, {} ", firstName, characters);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withList'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeWithListFirstName", firstName);
		parameters.put("myQueryTypeWithListCharacters", characters);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithList();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<Character> ret = queryType.withList(response, firstName, characters, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param firstName
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param characters
	 *            Parameter for the withList field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "withList", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.Character> withList(
			ObjectResponse objectResponse, String firstName, List<CharacterInput> characters, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'withList' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'withList' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeWithListFirstName", firstName);
		parameters.put("myQueryTypeWithListCharacters", characters);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getWithList();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the withList
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getWithListResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "withList",
				RequestType.query,
				InputParameter.newBindParameter("firstName", "myQueryTypeWithListFirstName", true, null),
				InputParameter.newBindParameter("characters", "myQueryTypeWithListCharacters", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the withList query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getWithListGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "withList",
				InputParameter.newBindParameter("firstName", "myQueryTypeWithListFirstName", true, null),
				InputParameter.newBindParameter("characters", "myQueryTypeWithListCharacters", true, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * AllFieldCases c = myQyeryType
	 * 		.allFieldCasesWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}", input, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param input
	 *            Parameter for the allFieldCases field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "allFieldCases", graphQLTypeSimpleName = "AllFieldCases", javaClass = AllFieldCases.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.AllFieldCases allFieldCasesWithBindValues(
			String queryResponseDef, AllFieldCasesInput input, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'allFieldCases' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getAllFieldCasesResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return allFieldCases(objectResponse, input, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * AllFieldCases c = myQyeryType.allFieldCases("{id name @skip(if: false) appearsIn friends {id name}}", input,
	 * 		"skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param input
	 *            Parameter for the allFieldCases field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "allFieldCases", graphQLTypeSimpleName = "AllFieldCases", javaClass = AllFieldCases.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.AllFieldCases allFieldCases(String queryResponseDef,
			AllFieldCasesInput input, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'allFieldCases' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getAllFieldCasesResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return allFieldCasesWithBindValues(objectResponse, input,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * AllFieldCases ret = queryType.allFieldCasesWithBindValues(response, input, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param input
	 *            Parameter for the allFieldCases field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "allFieldCases", graphQLTypeSimpleName = "AllFieldCases", javaClass = AllFieldCases.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.AllFieldCases allFieldCasesWithBindValues(
			ObjectResponse objectResponse, AllFieldCasesInput input, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'allFieldCases' with parameters: {} ", input);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'allFieldCases'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeAllFieldCasesInput", input);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getAllFieldCases();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * AllFieldCases ret = queryType.allFieldCases(response, input, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param input
	 *            Parameter for the allFieldCases field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "allFieldCases", graphQLTypeSimpleName = "AllFieldCases", javaClass = AllFieldCases.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.AllFieldCases allFieldCases(
			ObjectResponse objectResponse, AllFieldCasesInput input, Object... paramsAndValues)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'allFieldCases' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'allFieldCases' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeAllFieldCasesInput", input);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getAllFieldCases();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the AllFieldCases, as expected by the
	 * allFieldCases query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getAllFieldCasesResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "allFieldCases",
				RequestType.query,
				InputParameter.newBindParameter("input", "myQueryTypeAllFieldCasesInput", false, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the allFieldCases query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getAllFieldCasesGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "allFieldCases",
				InputParameter.newBindParameter("input", "myQueryTypeAllFieldCasesInput", false, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * List<AnyCharacter> c = myQyeryType.unionTestWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", human1, human2, droid1, droid2, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param human1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param human2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "unionTest", graphQLTypeSimpleName = "AnyCharacter", javaClass = AnyCharacter.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.AnyCharacter> unionTestWithBindValues(
			String queryResponseDef, HumanInput human1, HumanInput human2, DroidInput droid1, DroidInput droid2,
			Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'unionTest' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getUnionTestResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return unionTest(objectResponse, human1, human2, droid1, droid2, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * List<AnyCharacter> c = myQyeryType.unionTest("{id name @skip(if: false) appearsIn friends {id name}}", human1,
	 * 		human2, droid1, droid2, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param human1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param human2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "unionTest", graphQLTypeSimpleName = "AnyCharacter", javaClass = AnyCharacter.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.AnyCharacter> unionTest(
			String queryResponseDef, HumanInput human1, HumanInput human2, DroidInput droid1, DroidInput droid2,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'unionTest' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getUnionTestResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return unionTestWithBindValues(objectResponse, human1, human2, droid1, droid2,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<AnyCharacter> ret = queryType.unionTestWithBindValues(response, human1, human2, droid1, droid2, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param human1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param human2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "unionTest", graphQLTypeSimpleName = "AnyCharacter", javaClass = AnyCharacter.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.AnyCharacter> unionTestWithBindValues(
			ObjectResponse objectResponse, HumanInput human1, HumanInput human2, DroidInput droid1, DroidInput droid2,
			Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'unionTest' with parameters: {}, {}, {}, {} ", human1, human2, droid1,
					droid2);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'unionTest'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeUnionTestHuman1", human1);
		parameters.put("myQueryTypeUnionTestHuman2", human2);
		parameters.put("myQueryTypeUnionTestDroid1", droid1);
		parameters.put("myQueryTypeUnionTestDroid2", droid2);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getUnionTest();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<AnyCharacter> ret = queryType.unionTest(response, human1, human2, droid1, droid2, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param human1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param human2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid1
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param droid2
	 *            Parameter for the unionTest field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "unionTest", graphQLTypeSimpleName = "AnyCharacter", javaClass = AnyCharacter.class)
	public List<com.graphql_java_generator.client.domain.allGraphQLCases.AnyCharacter> unionTest(
			ObjectResponse objectResponse, HumanInput human1, HumanInput human2, DroidInput droid1, DroidInput droid2,
			Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'unionTest' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'unionTest' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeUnionTestHuman1", human1);
		parameters.put("myQueryTypeUnionTestHuman2", human2);
		parameters.put("myQueryTypeUnionTestDroid1", droid1);
		parameters.put("myQueryTypeUnionTestDroid2", droid2);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getUnionTest();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the AnyCharacter, as expected by the
	 * unionTest query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getUnionTestResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "unionTest",
				RequestType.query, InputParameter.newBindParameter("human1", "myQueryTypeUnionTestHuman1", false, null),
				InputParameter.newBindParameter("human2", "myQueryTypeUnionTestHuman2", false, null),
				InputParameter.newBindParameter("droid1", "myQueryTypeUnionTestDroid1", false, null),
				InputParameter.newBindParameter("droid2", "myQueryTypeUnionTestDroid2", false, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the unionTest query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getUnionTestGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "unionTest",
				InputParameter.newBindParameter("human1", "myQueryTypeUnionTestHuman1", false, null),
				InputParameter.newBindParameter("human2", "myQueryTypeUnionTestHuman2", false, null),
				InputParameter.newBindParameter("droid1", "myQueryTypeUnionTestDroid1", false, null),
				InputParameter.newBindParameter("droid2", "myQueryTypeUnionTestDroid2", false, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType.errorWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		errorLabel, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param errorLabel
	 *            Parameter for the error field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "error", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character errorWithBindValues(
			String queryResponseDef, String errorLabel, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'error' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getErrorResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return error(objectResponse, errorLabel, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.error("{id name @skip(if: false) appearsIn friends {id name}}", errorLabel, "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param errorLabel
	 *            Parameter for the error field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "error", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character error(String queryResponseDef,
			String errorLabel, Object... paramsAndValues)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'error' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getErrorResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return errorWithBindValues(objectResponse, errorLabel,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.errorWithBindValues(response, errorLabel, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param errorLabel
	 *            Parameter for the error field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "error", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character errorWithBindValues(
			ObjectResponse objectResponse, String errorLabel, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'error' with parameters: {} ", errorLabel);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'error'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeErrorErrorLabel", errorLabel);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getError();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.error(response, errorLabel, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param errorLabel
	 *            Parameter for the error field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "error", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character error(ObjectResponse objectResponse,
			String errorLabel, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'error' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'error' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeErrorErrorLabel", errorLabel);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getError();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the error
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getErrorResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "error", RequestType.query,
				InputParameter.newBindParameter("errorLabel", "myQueryTypeErrorErrorLabel", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the error query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getErrorGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "error",
				InputParameter.newBindParameter("errorLabel", "myQueryTypeErrorErrorLabel", true, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * _break c = myQyeryType.aBreakWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}", params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "aBreak", graphQLTypeSimpleName = "break", javaClass = _break.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases._break aBreakWithBindValues(String queryResponseDef,
			Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'aBreak' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getABreakResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return aBreak(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * _break c = myQyeryType.aBreak("{id name @skip(if: false) appearsIn friends {id name}}", "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "aBreak", graphQLTypeSimpleName = "break", javaClass = _break.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases._break aBreak(String queryResponseDef,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'aBreak' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getABreakResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return aBreakWithBindValues(objectResponse, graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * _break ret = queryType.aBreakWithBindValues(response, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "aBreak", graphQLTypeSimpleName = "break", javaClass = _break.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases._break aBreakWithBindValues(
			ObjectResponse objectResponse, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'aBreak' with parameters: ");
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'aBreak'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getABreak();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * _break ret = queryType.aBreak(response, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "aBreak", graphQLTypeSimpleName = "break", javaClass = _break.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases._break aBreak(ObjectResponse objectResponse,
			Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'aBreak' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'aBreak' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getABreak();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the _break, as expected by the aBreak
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getABreakResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "aBreak", RequestType.query);
	}

	/**
	 * Get the {@link GraphQLRequest} for the aBreak query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getABreakGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "aBreak");
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * List<String> c = myQyeryType.directiveOnQueryWithBindValues(
	 * 		"{id name @skip(if: false) appearsIn friends {id name}}", uppercase, params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param uppercase
	 *            Parameter for the directiveOnQuery field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "directiveOnQuery", graphQLTypeSimpleName = "String", javaClass = String.class)
	public List<java.lang.String> directiveOnQueryWithBindValues(String queryResponseDef, Boolean uppercase,
			Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'directiveOnQuery' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getDirectiveOnQueryResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return directiveOnQuery(objectResponse, uppercase, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * List<String> c = myQyeryType.directiveOnQuery("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		uppercase, "skip", Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param uppercase
	 *            Parameter for the directiveOnQuery field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "directiveOnQuery", graphQLTypeSimpleName = "String", javaClass = String.class)
	public List<java.lang.String> directiveOnQuery(String queryResponseDef, Boolean uppercase,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'directiveOnQuery' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getDirectiveOnQueryResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return directiveOnQueryWithBindValues(objectResponse, uppercase,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<String> ret = queryType.directiveOnQueryWithBindValues(response, uppercase, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param uppercase
	 *            Parameter for the directiveOnQuery field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "directiveOnQuery", graphQLTypeSimpleName = "String", javaClass = String.class)
	public List<java.lang.String> directiveOnQueryWithBindValues(ObjectResponse objectResponse, Boolean uppercase,
			Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'directiveOnQuery' with parameters: {} ", uppercase);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'directiveOnQuery'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryTypeDirectiveOnQueryUppercase", uppercase);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getDirectiveOnQuery();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * List<String> ret = queryType.directiveOnQuery(response, uppercase, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param uppercase
	 *            Parameter for the directiveOnQuery field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLScalar(fieldName = "directiveOnQuery", graphQLTypeSimpleName = "String", javaClass = String.class)
	public List<java.lang.String> directiveOnQuery(ObjectResponse objectResponse, Boolean uppercase,
			Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'directiveOnQuery' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'directiveOnQuery' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryTypeDirectiveOnQueryUppercase", uppercase);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getDirectiveOnQuery();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the String, as expected by the
	 * directiveOnQuery query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDirectiveOnQueryResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "directiveOnQuery",
				RequestType.query,
				InputParameter.newBindParameter("uppercase", "myQueryTypeDirectiveOnQueryUppercase", false, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the directiveOnQuery query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDirectiveOnQueryGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "directiveOnQuery",
				InputParameter.newBindParameter("uppercase", "myQueryTypeDirectiveOnQueryUppercase", false, null));
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * Character c = myQyeryType
	 * 		.directiveOnFieldWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}", params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "directiveOnField", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character directiveOnFieldWithBindValues(
			String queryResponseDef, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'directiveOnField' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getDirectiveOnFieldResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return directiveOnField(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Character c = myQyeryType.directiveOnField("{id name @skip(if: false) appearsIn friends {id name}}", "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "directiveOnField", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character directiveOnField(String queryResponseDef,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'directiveOnField' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getDirectiveOnFieldResponseBuilder().withQueryResponseDef(queryResponseDef)
				.build();
		return directiveOnFieldWithBindValues(objectResponse,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.directiveOnFieldWithBindValues(response, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "directiveOnField", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character directiveOnFieldWithBindValues(
			ObjectResponse objectResponse, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'directiveOnField' with parameters: ");
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'directiveOnField'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getDirectiveOnField();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * Character ret = queryType.directiveOnField(response, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "directiveOnField", graphQLTypeSimpleName = "Character", javaClass = Character.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.Character directiveOnField(
			ObjectResponse objectResponse, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'directiveOnField' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'directiveOnField' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getDirectiveOnField();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the Character, as expected by the
	 * directiveOnField query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getDirectiveOnFieldResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "directiveOnField",
				RequestType.query);
	}

	/**
	 * Get the {@link GraphQLRequest} for the directiveOnField query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getDirectiveOnFieldGraphQLRequest(String partialRequest)
			throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "directiveOnField");
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * MyQueryType c = myQyeryType.relayWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "relay", graphQLTypeSimpleName = "MyQueryType", javaClass = MyQueryType.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.MyQueryType relayWithBindValues(
			String queryResponseDef, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'relay' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getRelayResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return relay(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * MyQueryType c = myQyeryType.relay("{id name @skip(if: false) appearsIn friends {id name}}", "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "relay", graphQLTypeSimpleName = "MyQueryType", javaClass = MyQueryType.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.MyQueryType relay(String queryResponseDef,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query 'relay' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = getRelayResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return relayWithBindValues(objectResponse, graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * MyQueryType ret = queryType.relayWithBindValues(response, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "relay", graphQLTypeSimpleName = "MyQueryType", javaClass = MyQueryType.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.MyQueryType relayWithBindValues(
			ObjectResponse objectResponse, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query 'relay' with parameters: ");
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'relay'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getRelay();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * MyQueryType ret = queryType.relay(response, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "relay", graphQLTypeSimpleName = "MyQueryType", javaClass = MyQueryType.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.MyQueryType relay(ObjectResponse objectResponse,
			Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query 'relay' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query 'relay' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.getRelay();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the MyQueryType, as expected by the relay
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder getRelayResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "relay", RequestType.query);
	}

	/**
	 * Get the {@link GraphQLRequest} for the relay query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest getRelayGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "relay");
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * __Schema c = myQyeryType.__schemaWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}",
	 * 		params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Schema __schemaWithBindValues(
			String queryResponseDef, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query '__schema' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = get__schemaResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __schema(objectResponse, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * __Schema c = myQyeryType.__schema("{id name @skip(if: false) appearsIn friends {id name}}", "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Schema __schema(String queryResponseDef,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query '__schema' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = get__schemaResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __schemaWithBindValues(objectResponse,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * __Schema ret = queryType.__schemaWithBindValues(response, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Schema __schemaWithBindValues(
			ObjectResponse objectResponse, Map<String, Object> parameters) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query '__schema' with parameters: ");
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query '__schema'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.get__schema();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * __Schema ret = queryType.__schema(response, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__schema", graphQLTypeSimpleName = "__Schema", javaClass = __Schema.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Schema __schema(ObjectResponse objectResponse,
			Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query '__schema' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query '__schema' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.get__schema();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the __Schema, as expected by the __schema
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder get__schemaResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "__schema",
				RequestType.query);
	}

	/**
	 * Get the {@link GraphQLRequest} for the __schema query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest get__schemaGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "__schema");
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("skip", Boolean.FALSE);
	 *
	 * __Type c = myQyeryType.__typeWithBindValues("{id name @skip(if: false) appearsIn friends {id name}}", name,
	 * 		params);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param name
	 *            Parameter for the __type field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Type __typeWithBindValues(String queryResponseDef,
			String name, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query '__type' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = get__typeResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __type(objectResponse, name, parameters);
	}

	/**
	 * This method executes a partial query against the GraphQL server. That is, the query that is one of the queries
	 * defined in the GraphQL query object. The queryResponseDef contains the part of the query that <B><U>is
	 * after</U></B> the query name.<BR/>
	 * For instance, if the query hero has one parameter (as defined in the GraphQL schema):
	 * 
	 * <PRE>
	 * __Type c = myQyeryType.__type("{id name @skip(if: false) appearsIn friends {id name}}", name, "skip",
	 * 		Boolean.FALSE);
	 * </PRE>
	 * 
	 * It offers a logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method takes care of writing the query name, and the parameter(s) for the query. The given queryResponseDef
	 * describes the format of the response of the server response, that is the expected fields of the {@link Character}
	 * GraphQL type. It can be something like "{ id name }", if you want these fields of this type. Please take a look
	 * at the StarWars, Forum and other samples for more complex queries.<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.
	 * 
	 * @param queryResponseDef
	 *            The response definition of the query, in the native GraphQL format (see here above)
	 * @param name
	 *            Parameter for the __type field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestPreparationException
	 *             When an error occurs during the request preparation, typically when building the
	 *             {@link ObjectResponse}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Type __type(String queryResponseDef, String name,
			Object... paramsAndValues) throws GraphQLRequestExecutionException, GraphQLRequestPreparationException {
		logger.debug("Executing of query '__type' in query mode: {} ", queryResponseDef);
		ObjectResponse objectResponse = get__typeResponseBuilder().withQueryResponseDef(queryResponseDef).build();
		return __typeWithBindValues(objectResponse, name,
				graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues));
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * Map<String, Object> params = new HashMap<>();
	 * params.put("sinceParam", sinceValue);
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * __Type ret = queryType.__typeWithBindValues(response, name, params);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param name
	 *            Parameter for the __type field of MyQueryType, as defined in the GraphQL schema
	 * @param parameters
	 *            The list of values, for the bind variables defined in the query. If there is no bind variable in the
	 *            defined Query, this argument may be null or an empty {@link Map}
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Type __typeWithBindValues(
			ObjectResponse objectResponse, String name, Map<String, Object> parameters)
			throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			logger.trace("Executing of query '__type' with parameters: {} ", name);
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query '__type'");
		}

		// Given values for the BindVariables
		parameters = (parameters != null) ? parameters : new HashMap<>();
		parameters.put("myQueryType__typeName", name);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.get__type();
	}

	/**
	 * This method is expected by the graphql-java framework. It will be called when this query is called. It offers a
	 * logging of the call (if in debug mode), or of the call and its parameters (if in trace mode).<BR/>
	 * This method is valid for queries/mutations/subscriptions which don't have bind variables, as there is no
	 * <I>parameters</I> argument to pass the list of values.<BR/>
	 * Here is a sample:
	 * 
	 * <PRE>
	 * ObjectResponse response;
	 * public void setup() {
	 * 	// Preparation of the query
	 * 	response = queryType.getBoardsResponseBuilder()
	 * 			.withQueryResponseDef("{id name publiclyAvailable topics(since:?sinceParam){id}}").build();
	 * }
	 * 
	 * public void doTheJob() {
	 * ..
	 * // This will set the value sinceValue to the sinceParam field parameter
	 * __Type ret = queryType.__type(response, name, "sinceParam", sinceValue);
	 * ...
	 * }
	 * </PRE>
	 * 
	 * @param objectResponse
	 *            The definition of the response format, that describes what the GraphQL server is expected to return
	 * @param name
	 *            Parameter for the __type field of MyQueryType, as defined in the GraphQL schema
	 * @param paramsAndValues
	 *            This parameter contains all the name and values for the Bind Variables defined in the objectResponse
	 *            parameter, that must be sent to the server. Optional parameter may not have a value. They will be
	 *            ignored and not sent to the server. Mandatory parameter must be provided in this argument.<BR/>
	 *            This parameter contains an even number of parameters: it must be a series of name and values :
	 *            (paramName1, paramValue1, paramName2, paramValue2...)
	 * @throws GraphQLRequestExecutionException
	 *             When an error occurs during the request execution, typically a network error, an error from the
	 *             GraphQL server or if the server response can't be parsed
	 */
	@GraphQLNonScalar(fieldName = "__type", graphQLTypeSimpleName = "__Type", javaClass = __Type.class)
	public com.graphql_java_generator.client.domain.allGraphQLCases.__Type __type(ObjectResponse objectResponse,
			String name, Object... paramsAndValues) throws GraphQLRequestExecutionException {
		if (logger.isTraceEnabled()) {
			StringBuffer sb = new StringBuffer();
			sb.append("Executing of query '__type' with bind variables: ");
			boolean addComma = false;
			for (Object o : paramsAndValues) {
				if (o != null) {
					sb.append(o.toString());
					if (addComma)
						sb.append(", ");
					addComma = true;
				}
			}
			logger.trace(sb.toString());
		} else if (logger.isDebugEnabled()) {
			logger.debug("Executing of query '__type' (with bind variables)");
		}

		Map<String, Object> parameters = graphqlClientUtils.generatesBindVariableValuesMap(paramsAndValues);
		parameters.put("myQueryType__typeName", name);

		MyQueryType ret = configuration.getQueryExecutor().execute(objectResponse, parameters, MyQueryType.class);

		return ret.get__type();
	}

	/**
	 * Get the {@link com.graphql_java_generator.client.request.Builder} for the __Type, as expected by the __type
	 * query.
	 * 
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public com.graphql_java_generator.client.request.Builder get__typeResponseBuilder()
			throws GraphQLRequestPreparationException {
		return new com.graphql_java_generator.client.request.Builder(GraphQLRequest.class, "__type", RequestType.query,
				InputParameter.newBindParameter("name", "myQueryType__typeName", true, null));
	}

	/**
	 * Get the {@link GraphQLRequest} for the __type query, created with the given Partial request.
	 * 
	 * @param partialRequest
	 *            The Partial GraphQLRequest, as explained in the
	 *            <A HREF="https://graphql-maven-plugin-project.graphql-java-generator.com/client.html">plugin client
	 *            documentation</A>
	 * @return
	 * @throws GraphQLRequestPreparationException
	 */
	public GraphQLRequest get__typeGraphQLRequest(String partialRequest) throws GraphQLRequestPreparationException {
		return new GraphQLRequest(partialRequest, RequestType.query, "__type",
				InputParameter.newBindParameter("name", "myQueryType__typeName", true, null));
	}

	@Override
	public void setExtensions(JsonNode extensions) {
		// TODO Auto-generated method stub

	}

}
